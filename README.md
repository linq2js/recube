<!-- vscode-markdown-toc -->

- [Recube](#recube)
  - [Introduction](#introduction)
    - [Key Features](#key-features)
  - [Getting Started](#getting-started)
    - [Installation](#installation)
    - [Let's create Counter App](#lets-create-counter-app)
  - [Core Concepts](#core-concepts)
    - [States](#states)
    - [Actions](#actions)
    - [Cubes](#cubes)

<!-- vscode-markdown-toc-config
	numbering=false
	autoSave=true
/vscode-markdown-toc-config -->

<!-- /vscode-markdown-toc -->

# Recube

Revolutionizing state management in React, Recube is crafted to prioritize ease of use, minimalism, and high performance. Our aim is to demystify state management in React, making it a straightforward and intuitive process for developers.

## Introduction

Recube revolutionizes the way developers handle state management in React applications. It's designed with a philosophy that emphasizes ease of use, minimalism, and performance. Our goal is to simplify the developer's experience, making state management in React as intuitive and straightforward as possible.

### Key Features

**Fine-Grained Reactivity:** Recube introduces an innovative approach to state updates, ensuring that only the necessary components re-render in response to state changes. This precise reactivity not only enhances performance but also leads to more predictable and manageable UI behavior.

**Zero Boilerplate Philosophy:** We believe in keeping things simple. Recube eliminates the verbose and cumbersome boilerplate code often associated with state management in React, allowing for cleaner, more readable, and maintainable code.

**No Hooks Required:** With Recube, managing state does not require the use of React hooks. This design choice streamlines the codebase and reduces the learning curve, making it accessible even to those new to React.

**Optimized Rendering Performance:** Performance is key in modern web applications. Recube is engineered for fast rendering and high rendering optimization, ensuring your applications stay responsive and efficient, regardless of scale.

**Simplified Asynchronous Data Handling:** Recube tackles one of the more complex aspects of React development - asynchronous data management. It provides elegant solutions that work seamlessly with React's existing capabilities like Suspense and ErrorBoundary, making async operations more straightforward.

Recube is more than just a state management library; it's a new paradigm in React development. It strips away the complexities traditionally associated with state management, allowing developers to focus on building great applications with less overhead.

## Getting Started

### Installation

`Recube` can be installed by adding the `recube` package to your project:

```bash
npm install recube

# or

yarn add recube
```

Once installed via your package manager of choice, you're ready to import it in your app.

### Let's create Counter App

```js
import { state } from 'recube';
import { rx } from 'recube/react';

const count = state(0);
const App = () => <h1 onClick={() => count.set(x => x + 1)}>{rx(count)}</h1>;
```

In this example, creating a Counter app is efficiently accomplished in just two lines.

The first line introduces a `state` using the `state` function, which accepts an initial value.

The second line presents the `App` component as a functional component. It renders an `h1` tag displaying the current `count` state. The `rx` function is utilized for rendering the `state` value.

> This exemplifies Recube's fine-grained reactivity: when the `count` state alters, it doesn't trigger a re-render of the `App` component. Instead, only the ReactNode generated by the `rx` function re-renders. Notably, this process is achieved without employing any hooks for state and component connection.

## Core Concepts

### States

In Recube, a `state` represents a piece of data or a value that can change over time. It's reactive, meaning whenever the state changes, it can automatically trigger updates in the UI.

```js
import { state } from 'recube';

// declare state with initial value
const count = state(0);

// update state value
count.set(2);

// using reducer to update state value
count.set(prev => prev + 1);

// access state value
console.log(count()); // 3
```

### Actions

An `action` is an event or a trigger that causes the `state` to change. It's a way of sending signals to the state to update its value, often based on some logic or conditions.

```js
import { state, action } from 'recube';

// assume that increment has no payload
const increment = action(); // increment()
// assume that incrementBy has a payload of number type
const incrementBy = action(); // incrementBy(2)
// declare an action with body
const incrementWithServerValue = action(async () => {
  return fetchServerData();
});

// declare a state and listen for actions to update state value
const count = state(1)
  // listen void action, the reducer does not need action result/payload
  .when(increment, prev => prev + 1)
  // listen an action has payload, the reducer has 2 parameters: previous state value and action payload
  .when(incrementBy, (prev, by) => prev + by)
  // when listen for an action with body, the second parameter of reducer is action result
  // if the action returns Promise object, the action waits until the promise is resolved, it will pass resolved to reducer as second parameter
  .when(incrementWithServerValue, (prev, serverValue) => prev + serverValue);

// trigger actions
increment(); // return void
incrementBy(2); // return void
incrementWithServerValue(); // return Promise object
```

### Cubes

`Cube` is a bit more abstract. It's a component or a mechanism that binds the `state` and its corresponding UI updates together. When the state changes, the `cube` ensures that only the relevant parts of the UI are updated efficiently.
